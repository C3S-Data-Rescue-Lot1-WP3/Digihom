<?php
  /*
   leere ol-tags führen zu unschönen resultaten -> auto-remove?
   open('li') close(1) führt zu fehlern (li bleibt offen, xhtml-only?)
   a-construction new (this->args inkl anchor-part) 
   a: trennen intern/extern etc
   colgroup-shortcut
   spzialisierte objekte(tabelle, listen etc, mit eingeschränkter/definierter funktion)
   grundklasse nicht direkt einbinden, damit verschieden opc_ht möglich sind?
   add placeholder and replace them later
   create index and similar things (using placeholder and collecting functions)
   use htmlspecialchars utf8_encode etc. automatically or by special attrs!
   rewind-function to back inside stack
   class/style with enhanced functions (as array; replace, add, modify)
   close to a tag/name/id inkl relative 
     eg close all up to the top most table, without the table itslef and so on
   embedd: embedd the current tag by  
   strip: strip current tag (removes tag and attribute and return them

   idea:
   own class to pictures (Slideshows and so on)

  */

  /*
   common ruels
   
   elemts-structer: this class creates the elements as nested named arrays
     the key tag defines the kind of the tag itself
     all other string-keys defines attributes
     all numerber-keys defines the childs (they will be used in sorted order)

   argument attr:
     in flat structers attr is a named array which contains additional attributes.
     Special attributes are allowed. In nested structer a key may also reference
     a part of the complex structure (see path-syntax below), in this case the value
     is another named array which is used for the pointed structure. If only
     on attribue should be defined you may use a shortcut in the form path#class

     if attr is a simple text it will be used as style or class attribute 

     path syntax: all pathes starts with a point (really all). The html-structure
     is represented by a .-separated path (eg .table.tr.th). You may use the following
     shortcuts
       .* -> 0 or more levels; eg .*.li will match all li-elements
                                  .*.li.* will also include all kind elements of them
       .+ -> 1 or more levels (similar to .*)
       .3 -> 3 levels
       .^ -> similar to .* but no tag of the same kind as the next element
                               eg .^.ul will refer to the first ul-list but not to a nested one
       you may use other preg_grep syntax. Remember the '.' is used to separate the levels!
                               eg .*.(ul|ol).li.b
     the attribute 'tag' will be used for the tag-name and not as attribute itself

     additional to the html-attributes used inside the tags there exists some special
     attributes, which are only used for creating the whole structer. They will not
     appear in the final source code. All this attributes start with a double underscore
       __head and __foot: The content of them will not be used as an attribute but as
         first (index -1) and last child of the content. Useful to add text at the front
         and end of a item.
       __name: Will insert a <a name="..."></a> as first child
       __col, __row, __i, __p will be set to identify the current row and
         column (tables), item (ul, ol, dl ...) or path (nested like "1.2.1")
       __callback: value defines the name of a callable method/function
         A method is prefered. A function may also be generated by create_function
	 The method/function gets the current element as array (see above)
	 It may modify this but should return it at the end (in a valid form)
	 The argument includes all (special) attributes. Modifiers were already applied

     you can add one or more special modifiers at the end of a tag (separated by a space)
        if non is given '+' is used. Not all combination make sense.
        - -> only used if attribute is not yet set
	= -> will overwrite existing attribute
	+ -> will add the new value separated by a space (default)
        c -> value is an arry which is used cyclic
	n -> value is an array and the n'th value is used (or nothing)
	[others] -> value is an array and the modifier refers to an existing
	            key in it. The value of it will be used as key for the value

   some functions have up to three variations
         [name] -> saves the result into the stack; no return value
         [name]2str -> returns the result as string; stack is not changed
	 [name]2arr -> returns the result as (nested) array; stack is not changed
  */

require_once('opl_basic.php');
require_once('ops_array.php');

class opc_ht {
  /* array with the real content 
   element 0 ... n-1: tags as arrays
   element n-1: array of top-items (will not be embedded by a tag)*/
  var $stack = array(); 
  var $xhtml = FALSE; //xhmtl or html
  var $srclayout = 1;//0 no layout in source, 1: basic
  var $args = array();
  var $url = NULL;

  function opc_ht($xhtml=FALSE){
    $this->init($xhtml);
    $this->url = $this->myself();
  }

  function init($xhtml){
    $this->reset();
    $this->xhtml = $xhtml == TRUE;
  }

  function reset(){
    $this->stack = array(array());
    $this->args = array();
  }


  /*  add a new element as last item/child
      data is a tag (as array), 
              a string 
	      an array of strings 
	      an array similar to stack (set rev in this case to TRUE! */
  function add($data="\n",$rev=FALSE){
    $this->arradd($this->stack,$data,$rev);
    return($data);
  }

  function attr_merge(/* */){
    $res = array();
    $ar = func_get_args();
    foreach($ar as $ca) $res = array_merge($res,array_filter($ca));
    return $res;
  }
  
  function addattr($name,$data="\n"){
    ops_array::set($this->stack[0],$name,$data);
  }

  /* simply embeds content by a tag */
  function tag    ($tag,$data=NULL,$attr=array()){$this->add($this->tag2arr($tag,$data,$attr));}
  function tag2str($tag,$data=NULL,$attr=array()){return($this->_implode2str($this->tag2arr($tag,$data,$attr)));}
  function tag2arr($tag,$data=NULL,$attr=array()){
    $attr = $this->_attr_auto($attr,$tag);
    if(!is_null($data)){
      if(!is_array($data)) $attr[] = $data;
      else if(array_key_exists('tag',$data)) $attr[] = $data;
      else $attr = array_merge($attr,$data);
    }
    return($this->implode2arr($attr));
  }

  /* simple tag with no childdata */
  function stag    ($tag,$attr=array()){$this->add($this->tag    ($tag,NULL,$attr));}
  function stag2str($tag,$attr=array()){    return($this->tag2str($tag,NULL,$attr));}
  function stag2arr($tag,$attr=array()){    return($this->tag2arr($tag,NULL,$attr));}

  /* unknown tag (saved in attr or standrad span */
  function utag    ($data,$attr=array()){$this->add($this->utag2arr($data,$attr));}
  function utag2str($data,$attr=array()){    return($this->utag2arr($data,$attr));}
  function utag2arr($data,$attr=array()){    
    if(!array_key_exists('tag',$attr)) return $this->tag2arr('span',$data,$attr);
    if(is_null($attr['tag'])) return $this->add($data);
    $tag = $attr['tag'];
    unset($attr['tag']);
    return $this->tag2arr($tag,$data,$attr);
  }

  /*
   opens a new tag. Further add commands (an similar) will produce childs of this node
   close the node with method close
   tag: if NULL it should be already defined in attr
   attr: no nested keys or pattern keys allowed, no modificators.
   */
  function open($tag,$attr=array()){
    array_unshift($this->stack,$this->open2arr($tag,$attr));
  }
  function open2str($tag,$attr=array()){
    return($this->_implode2str($this->open2arr($tag,$attr),1));
  }
  function open2arr($tag,$attr=array()){ // equal to stag2arr!
    return($this->_attr_auto($attr,$tag));
  }
  
  /* opens one or more tags
   argument list is a sequence of tag names (string)
   an attribute array may optional inserted behind a tag-name
   save: 2 is handled like 1
   ~2arr makes no sense
   */
  function nopen(/*... */){
    $al = func_get_args();
    while(!is_null($tag = array_shift($al)))
      if(isset($al[0]) and is_array($al[0]))	$this->open($tag,array_shift($al));
      else      $this->open($tag);
  }
  function nopen2str(/*... */){
    $al = func_get_args();
    $res = '';
    while(!is_null($tag = array_shift($al)))
      $res .= $this->open($tag,is_array($al[0])?array_shift($al):array());
    return($res);
  }

  function reopen(){
    $res = $this->arrreopen($this->stack);
    if(!is_array($res)) return($res);
    $this->stack = $res;
    return(0);
  }


  /* closes one or more levels and adds them as child to the parent level
   >0: closs n levels (default 1)
   <0: close all levels except the highest n levels
   NULL: close all levels
   [string]: close all levels up to the first occurence of this tag (including this too)
   REM: save: not used since is neither a start of nor a complete node
   */
  function close($nlev=1)    { $this->stack = $this->arrclose($this->stack,$nlev);  }
  function close2str($nlev=1){ return($this->_implode2str($this->close2arr($nlev))); }
  function close2arr($nlev=1){
    $this->close($nlev);
    return(array_pop($this->stack[0]));
  }

  // similar to close, but only 1 level allowed but regards nested attributes and allows additional afterwards
  function closeStr    ($add_attr=array()){$this->add($this->closeStr2arr($add_attr));}
  function closeStr2str($add_attr=array()){return($this->_implode2str($this->closeStr2arr($add_attr)));}
  function closeStr2arr($add_attr=array()){
    $attr = array();
    $cont = array();
    $data = array_shift($this->stack);
    foreach($data as $key=>$val)
      if($key=='tag' or is_numeric($key)) $cont[$key] = $val; else $attr[$key] = $val;
    $attr = $this->attr_merge($attr,$add_attr);
    return($this->implode2arr($cont,$attr));
  }


  /*
   close and re-opens one or more tag (usefull in lists and tables)
   attr is an array -> close/reopens one tag, attr will be merged with the attributes
                       of the current tag
   attr is a number -> close/reopens n-tags (with the same attributes as before)
   REM: save: not used since is neither a start of nor a complete node
   ~2arr/~2str makes no sense
   */
  function next($attr=1){
    if(is_numeric($attr)) {
      $nlev = $attr;
      $attr = array();
    } else {
      $nlev = 1;
      $attr = array($this->_attr_auto($attr));
    }
    if($this->_cur_level()<$nlev) return(FALSE);
    $tag = array(); $att = array();
    for($ci=0;$ci<$nlev;$ci++) {
      $tag[$ci] = $this->_cur_tag($ci);
      if(isset($attr[$ci]))
	$att[$ci] = array_merge($this->_cur_attrs($ci),$attr[$ci]);
      else
	$att[$ci] = $this->_cur_attrs($ci);
    }
    $res = $this->close($nlev);
    for($ci=0;$ci<$nlev;$ci++) $res .= $this->open(array_pop($tag),array_pop($att));
    return($res);
  }

  
  /* creates a chain of similar elements
   data is an array of elements or an array of arrays lik  ('item','class'=>'myclass'...)
   inner/outer: null/tag-name/array of attributes (including tag-name)
   eg: chain(array(1,2,3),'li',array('tag'=>'ol','class'=>'list'))
   */
  function chain($data,$inner=NULL/* $outer ..*/){
    $ar = func_get_args(); 
    $this->add(call_user_func_array(array(&$this,'chain2arr'),$ar));
  }
  function chain2str($data,$inner=NULL/* $outer ..*/){
    $ar = func_get_args(); 
    return($this->_implode2str(call_user_func_array(array(&$this,'chain2arr'),$ar)));
  }
  function chain2arr($data,$inner=NULL/* $outer ..*/){
    $ar = func_get_args(); $na = count($ar);
    if(!is_array($data)) $data = array($data);
    if(!is_null($inner)){
      if(!is_array($inner)) $inner = array('tag'=>$inner);
      $ci = 0; $res = array();
      foreach($data as $cd){
	$cin = $inner;
	$cin['__i'] = $ci++;
	if(!is_array($cd)) $cin[0] = $cd;
	else $cin = array_merge($inner,$cd);
	$res[] = $cin;
      }
    } else $res = array_values($data);
    for($ii=2;$ii<$na;$ii++)
      $res = array_merge(is_array($ar[$ii])?$ar[$ii]:array('tag'=>$ar[$ii]),$res);
    return($this->implode2arr($res));
  }


  /* n-dimensional chain
   $data is a array of data or even another array for the next level
      an array with a 'tag'-key will be interpreted as html-structer (=single item)
   $nestedattrs: array of attribute-array
     foreach level used in data you need here two array of attributes
       the first is for the embedding tag of the top level (outer)
       the second is for the tags of the single items on top level (inner)
       the third is for embedding tag of the first sub-level (outer)
       the fourth ....
       a string will be used as array('tag'=>yourstring)
       a NULL for the inner attrs is allowed but not for the outer!
       if too few attr-arrays exist the last outer/inner pair is used
       eg: for a simple table use array('table',NULL,'tr','td')
       eg: for a table of list use array('table',NULL,'tr','td','ul','li')
       eg: for nested list use array('ol','li')
  */
  function tensor    ($data,$nattr=array()){$this->add($this->tensor2arr($data,$nattr));}
  function tensor2str($data,$nattr=array()){return($this->_implode2str($this->tensor2arr($data,$nattr)));}
  function tensor2arr($data,$nattr=array()){
    while(list($ak,$av)=each($nattr)) if(is_string($av)) $nattr[$ak] = array('tag'=>$av);
    return($this->implode2arr($this->_tensor($data,$nattr,''),array()));
  }

  function _tensor($data,$nattr,$path){
    $outer = array_shift($nattr);
    $outer['__p'] = substr($path,0,-1);
    $inner = array_shift($nattr);
    if(count($nattr)<2) $nattr = array($outer,$inner);
    if(is_null($inner)){
      while(list($ak,$av)=each($data)){
	if(is_array($av) and !array_key_exists('tag',$av))
	  $outer[] = $this->_tensor($av,$nattr,$path . $ak . '.');
	else
	  $outer[] = $av;
      }
    } else {
      while(list($ak,$av)=each($data)){
	$inner['__p'] = $path . $ak;
	if(is_array($av) and !array_key_exists('tag',$av))
	  $inner[0] = $this->_tensor($av,$nattr,$path . $ak . '.');
	else
	  $inner[0] = $av;
	$outer[] = $inner;
      }
    }
    return($outer);
  }

  /* transfer the data from another object (class opc_ht or subclass)
   close: close object before data transfer
   reset: reset object after data transfer
   returns T/F for success
   ~2arr/~2str makes no sense  */
  function in(&$obj,$close=FALSE,$reset=TRUE){
    if(!($obj instanceof opc_ht)) return(FALSE);
    if(!$close){
      $os = $obj->stack;
      $this->add(array_pop($os));
      $this->stack = array_merge($os,$this->stack);
      if($reset==TRUE) $obj->reset();
    } else $this->add($obj->output($reset));
    return(TRUE);
  }

  /* similar to in but will close and reset the object and import it as content of a tag
   ~2arr makes no sense */
  function in_tag    (&$obj,$tag,$attrs=array()){$this->tag($tag,$obj->output(TRUE),$attrs);}
  function in_tag2str(&$obj,$tag,$attrs=array()){return($this->tag2str($tag,$obj->output(TRUE),$attrs));}

  /* gets an array (tag or array of tags) and makes a string out of it */
  function arr2str($data){
    die("not yet coded");
  }

  /* adds data to a arr-structer; rev:TRUE -> $data similar to stack */
  function arradd(&$stack,$data=NULL,$rev=FALSE){
    if(is_null($data) or $data==='') return($stack);
    if(!is_array($data)) $stack[0][] = $data;
    else if(array_key_exists('tag',$data)) $stack[0][] = $data;
    else if(count($stack)==0) $stack = array($data);
    else if($rev) $stack = array_merge($data,$stack);
    else $stack[0] = array_merge($stack[0],$data);
    return($stack);
  }

  /* adds attribute-data to a arr-structer */
  function arraddattr($stack,$name,$value=NULL){
    ops_array::set($stack[0],$name,$data);
    return($stack);
  }

  /* (partally) closes a arr-structer */
  function arrclose($data,$nlev=1){
    $mlev = count($data)-1; //top level stays
    if(is_null($nlev)){
      $nlev = $mlev;
    } else if(is_string($nlev)){
      for($cl=0;$cl<$mlev;$cl++) if($data[$cl]['tag']==$nlev) break;
      if($cl<$mlev) $nlev = $cl+1; else return($data);
    } else if($nlev<0){
      if(-$nlev>=$mlev) return($data); else $nlev += $mlev;
    } else if($nlev>$mlev) {
      return($data);
    } else if($nlev==0) {
      return($data);
    }

    while(count($data)>1){ //top level stays
      $ct = array_shift($data);
      $this->arradd($data,$this->_attr_spec($ct));
      if(--$nlev==0) break;
    }
    return($data);
  }

  /* reopens an array-(list-)structer */
  function arrreopen($data){
    if(isset($data['tag'])) $data = array($data); //
    $ak = array_reverse(array_keys($data[0]));
    while(!is_numeric($ck = array_shift($ak)));
    if(!is_numeric($ck)) return(1);
    $node = $data[0][$ck];
    if(!isset($node['tag'])) return(2);
    unset($data[0][$ck]);
    array_unshift($data,$node);
    return($data);
  }

 
  /* send its own output to another object (eg: class opc_ht or subclass)
   uses method add and open of this object
   ~2arr/~str makes no sense  */
  function sink(&$obj,$reset=TRUE){
    $stack = array_reverse($this->stack);
    $top = array_shift($stack);
    foreach($top as $ci)   $obj->add($ci);
    foreach($stack as $ci) $obj->open(NULL,$ci);
    if($reset) $this->reset();
  }
  

  /* close this instance and returns the content as valid (x)html string
   reset: if true the instance will be reinitialiced afterward*/
  function output($reset=TRUE){
    $this->close(NULL);
    $res = '';
    if(count($this->stack)>0)
      foreach($this->stack[0] as $cc) 
	$res .= is_array($cc)?$this->_implode2str($cc,0):$cc;
    if($reset==TRUE) $this->reset();
    return($res);
  }


  // implodes a nested structure
  function implode    ($data,$attr=array()){$this->add($this->implode2arr($data,$attr));}
  function implode2str($data,$attr=array()){return($this->_implode2str($this->implode2arr($data,$attr)));}
  function implode2arr($data,$attr=array()){
    if(!is_array($data)) return($data);
    return($this->_attr_include($data,$this->_attr_prepare($attr)));
  }

  /* subfunction for implode, does the final implode to a string; no side-effects */
  function _implode2str($data,$nopen=0){
    if(!is_array($data)) return($data);
    if(isset($data['tag'])){
      return($this->__implode2str($data,0,$nopen));
    } else {
      $res = array();
      foreach($data as $ci) 
	$res[] = is_array($ci)?$this->__implode2str($ci,0,0):$ci;
      return(implode("\n",$res));
    }
  }

  function __implode2str($data,$lev,$nopen){
    // divide data into tag (key=tag), attributes (string-key) and childs (num-key)
    $ad = array(); $cd = array(); 
    foreach(array_keys($data) as $ck){
      if($ck==='tag') $tag = $data[$ck];
      else if(is_string($ck)) $ad[$ck] = $data[$ck];
      else $cd[$ck] = $data[$ck];
    }
    $tindent = $this->_indent($tag);
    ksort($cd);
    $res = '<' . $tag . $this->implode_attr($ad);
    if(count($cd)==0){
      if($this->xhtml){
	$res .= ($lev>=$nopen)?' />':'>';
      } else {
	if($this->is_single($tag) or $lev<$nopen)
	  $res .= '>';
	else $res .= '></' . $tag . '>';
      }
    } else {
      $res .= '>';
      foreach($cd as $cc) $res .= is_array($cc)?$this->__implode2str($cc,$lev+1,$nopen):$cc;
      if($this->srclayout>0 and $tindent>0 and strlen($res)>80) 
	$res .= "\n" .  str_repeat(' ',$lev);
      if($lev>=$nopen) $res .= '</' . $tag . '>';
    }
    if($this->srclayout>0 and $tindent>0) 
      $res = str_repeat("\n",$tindent) .  str_repeat(' ',$lev) . $res;
    return($res);
    
  }


  //implodes a named array to a attribute string (no special attribute or modifiers)
  // no side-effects
  function implode_attr($attr){
    if(!is_array($attr)) return($attr);
    $res = '';
    while(list($ak,$av)=each($attr)){
      if(is_numeric($av))   $av = strval($av);
      if(is_string($av))    $res .= ' ' . $ak . '="' . htmlspecialchars($av,ENT_COMPAT) .'"';
      else if($this->xhtml) $res .= ' ' . $ak . '="' . $ak .'"';
      else                  $res .= ' ' . $ak;
    }
    return($res);
  }

  /* connect names and values of a named array to prepare implode for an url
   if impl is not null it will implode the result by this
  */
  function implode_urlargs($args=NULL,$impl=NULL){
    if(!is_array($args) or count($args)==0) return(NULL);
    $res = array();
    foreach($args as $ak=>$av){
      if(is_numeric($ak)) $res[] = urlencode($av);
      elseif(!is_array($av)) $res[] = $ak . '=' . urlencode($av);
      else foreach($av as $cv)  $res[] = $ak . '[]=' . urlencode($cv);
    }
    return(is_null($impl)?$res:implode($impl,$res));
  }


  /* returns the array of the last(current) open element */
  function return_last(){
    switch(count($this->stack)){
    case 0: return(NULL);
    case 1: return($this->stack[0][count($this->stack[0])-1]);
    default: 
      return($this->stack[0]);
    }
  }

  /* returns the tag-name at position (or all as array if pos is NULL) */
  function _cur_tag($pos=0){
    if(!is_null($pos)) return(isset($this->stack[$pos]['tag'])?$this->stack[$pos]['tag']:NULL);
    $res = array();
    $nl = count($this->stack);
    for($pos=0;$pos < $nl;$pos++)
      $res[$pos] = isset($this->stack[$pos]['tag'])?$this->stack[$pos]['tag']:NULL;
    return($res);
  }

  /* returns the attributes at position */
  function _cur_attrs($pos=0){
    $res = $this->stack[$pos];
    unset($res['tag']);
    $ak = array_keys($res);
    foreach($ak as $ck) if(is_numeric($ck)) unset($res[$ck]);
    return($res);
  }

  /* returns the childs at position */
  function _cur_childs($pos=0){
    $res = $this->stack[$pos];
    $ak = array_keys($res);
    foreach($ak as $ck) if(!is_numeric($ck)) unset($res[$ck]);
    return($res);
  }

  /* count childs at a position */
  function _count_childs($pos){
    $ak = array_keys($this->stack[$pos]);
    $res = 0;
    foreach($ak as $ck) if(is_numeric($ck)) $res++;
    return($res);
  }

  /* count childs at a position */
  function _count_attr($pos){
    $ak = array_keys($this->stack[$pos]);
    $res = 0;
    foreach($ak as $ck) if(!is_numeric($ck) and $ck!='tag') $res++;
    return($res);
  }

  /* returns the current level */
  function _cur_level(){ return(max(0,count($this->stack)-1)); }


  /* recognice a direct class or style attribute; 
   adds tagname if not NULL 
   and the values from add by merging
  */
  function _attr_auto($attr,$tag=NULL,$add=array()){
    if(is_null($attr)) $attr = array();
    else if(is_string($attr)){
      if(FALSE === strpos($attr,':')) $attr = array('class'=>$attr);
      else                            $attr = array('style'=>$attr);
    }
    if(!is_null($tag)) $attr['tag'] = $tag;
    return(array_merge($attr,$add));
  }




  /* allows to skip the top tag-name in attributes (except patterns)
     tag: top tagname
     subtags: array of possible sub tags
  */
  function _attr_shift($attrs,$tag,$subtags){
    $keys = array_keys($attrs);
    foreach($keys as $ak){
      if(preg_match('/^[_:a-zA-Z0-9]+$/',$ak)){
	if(in_array($ak,$subtags)) ops_array::rename($attrs,$ak,'.' . $tag . '.' . $ak);
	else if($ak!=$tag)         ops_array::rename($attrs,$ak,'.' . $tag . '#' . $ak);
      } else if(preg_match('/^[_:a-zA-Z0-9]+(\.[_a-zA-Z0-9]+)*(#[_:a-zA-Z0-9]+)?$/',$ak)){
	$tk = preg_replace('/^([_:a-zA-Z0-9]+)(\.[_a-zA-Z0-9]+)*(#[_:a-zA-Z0-9]+)?$/','$1',$ak);
	if($tk!=$ak)               ops_array::rename($attrs,$ak,'.' . $tag . '.' . $ak);
      }
    }
    return($attrs);
  }

  /* changes all attr-elements to the pattern-style versions; no side-effects */
  function _attr_prepare($attr){
    if(count($attr)==0) return(array());
    $tres = $this->_attr_prepare_rec($attr,array());
    $res = array();
    while(count($tres)>0){
      list($key,$val) = array_shift($tres);
      $key = '/^\.' . implode('\.',$key) . '$/';
      foreach($val as $vk=>$vv) $res[$key][$vk] = $vv;
    }
    return($res);
  }
  
  /* sub of _attr_prepare_rec */
  function _attr_prepare_rec($attr,$prefix){
    if(!is_array($attr) or count($attr)==0) return(array());
    $npat = '([A-Za-z0-9_:]+)';
    $res = array();
    foreach($attr as $key=>$val){
      if(strpos($key,'#')!==FALSE)
	list($key,$cls) = explode('#',$key,2); // separate shortcut
      else
	$cls = NULL;
      if(!empty($cls)) $val = array($cls=>$val); // if shortcut decode it
      $key = explode('.',$key); // explode key elements
      $nk = count($key);
      if($nk==1){ // key is an attribute on the current level
	if(count($prefix)>0)
	  $res[] = array($prefix,array($key[0]=>$val));
	else
	  $res[] = array(array_merge($prefix,array($npat)),array($key[0]=>$val));
      } else if(strlen($key[0])!=0){ // always start with a point!
	continue;
      } else {	// replace key-shortcuts/patterns
	$pf = $prefix;
	for($ii=1;$ii<$nk;$ii++){
	  if($key[$ii]=='*')
	    $pf[] =  "($npat(\\.$npat)*)?";
	  if($key[$ii]=='+') 
	    $pf[] =  "$npat(\\.$npat)*";
	  else if($key[$ii]=='^')
	    $pf[] = '[^(\.' . $key[$ii+1] . '\.)]*';
	  elseif(preg_match('/^[0-9]+$/',$key[$ii])){
	    $ij = ((int) $key[$ii])-1;
	    $pf[] = $ij>0?"$npat(\\.$npat)\{$ij}":$npat;
	  } else 
	    $pf[] = $key[$ii];
	}
	$res = array_merge($res,$this->_attr_prepare_rec($val,$pf));
      }
    }
    return($res);
  }


  /*fusions the attributes from attr with those from $data, which has to be an array
   including special attributes and modifiers;  no side-effects */
  function _attr_include($data,$attr,$path='.',$nth=0,$level=0){
    if(isset($data['tag'])) $path .= $data['tag'];
    while(list($ak,$av)=each($attr)){
      if(preg_match($ak,$path)){
	while(list($bk,$bv)=each($av)){
	  $mods = explode(' ',$bk);
	  $bk = array_shift($mods);
	  foreach($mods as $cmod){
	    switch(trim($cmod)){
	    case '+': case '-': case '=': break; // do nothing
	    case 'c': $bv = $bv[$nth % count($bv)]; break;
	    case 'n': 
	      if(isset($bv[$nth])) $bv = $bv[$nth]; else continue(3); break;
	    default:
	      $cmod = trim($cmod);
	      if(isset($data[$cmod])) 
		$bv = isset($bv[$data[$cmod]])?$bv[$data[$cmod]]:NULL;
	      else 
		$bv = NULL;
	      
	    }
	  }
	  switch(isset($mods[count($mods)-1])?trim($mods[count($mods)-1]):NULL){
	  case '=': 
	    if(!is_null($bv)) $data[$bk] = $bv; 
	    break;
	  case '-': 
	    if(!isset($data[$bk])) $data[$bk] = $bv; 
	    break;
	  default:
	    if(is_null($bv)) break;
	    if(isset($data[$bk])) $data[$bk] .= ' ' . $bv; else $data[$bk] = $bv; 
	    break;
	  }
	}
      }
    }
    //spec __-attributes
    $data = $this->_attr_spec($data);

    // go into nested areas
    foreach($data as $ak=>$av)
      if(is_numeric($ak) and is_array($av))
	$data[$ak] = $this->_attr_include($av,$attr,$path . '.',$ak,$level+1);
    return($data);
  }

  /* apply  __-attributes and remove them;  no side-effects */
  function _attr_spec($data){
    if(!is_array($data)) return($data);
    $ak = preg_grep('/^__/',array_keys($data));
    if(in_array('__callback',$ak)){ // has to be done first
      $av = $data['__callback'];
      if(method_exists($this,$av))    
	$data = call_user_func(array(&$this,$av),$data);
      else if(function_exists($av))   
	$data = call_user_func($av,$data); //php5&
    }

    foreach($ak as $ck){
      switch(substr($ck,2)){
      case 'foot': $data[] = $data[$ck]; break;
      case 'head': $data[-1] = $data[$ck]; break;
      case 'name': $data[-2] = array('tag'=>'a','name'=>$data[$ck],0=>''); break;
      }
      unset($data[$ck]);
    }
    return($data);
  }


  /*============================================================
   specialised open commands
   ============================================================ */

  /* helps to start a table
   twidth: TRUE or 1 or 100 -> attribute width=100%
   cwidth: integer -> equal size with n columns
   */
  function opentable2arr($twidth=NULL,$ncol=NULL,$attr=array()){
    $res = $this->_attr_auto($attr,'table');
    if(!is_null($twidth)){
      switch($twidth){
      case 100: case 1: case TRUE: $res['width'] = '100%'; break;
      default:
	$attr['width'] = $twidth;
      }
    }
    if(is_numeric($ncol)){
      $ncol = floor($ncol);
      $ar = array('span'=>$ncol,'width'=>floor(100/$ncol) . '%');
      $res[] = $this->tag2arr('colgroup',NULL,$ar);
    }
    return($res);
  }


  /*============================================================
   small things
   ============================================================ */

  /*
   levle: 1-4 for h-tags >4 will give a div-tag with h5 (or higher) class
   title: showed text
   name: will isnert a a-name-tag at the beginning (no text between)
   attr: additional attributes for the a-tag (non-nested)
  */
  function h    ($lev,$title,$name=NULL,$attr=array()){$this->add($this->h2arr($lev,$title,$name,$attr));}
  function h2str($lev,$title,$name=NULL,$attr=array()){return($this->_implode2str($this->h2arr($lev,$title,$name,$attr)));}
  function h2arr($lev,$title,$name=NULL,$attr=array()){
    $attr = $this->_attr_auto($attr);
    if($lev>6){
      $attr['tag'] = 'div';
      $attr['class'] = 'h' . $lev . ' ' . $attr[$class];
    } else $attr['tag'] = 'h' . $lev;
    if(!is_null($name)) $attr[] = array('tag'=>'a','name'=>$name,0=>'');
    $attr[] = $title;
    return($this->implode2arr($attr));
  }


  /* creates a link
   txt: displayed text
   url: link base or 
     0 -> current site including php-arguments
     1 -> current site without php-arguments
   args: additional php-arguments as named array
   anchor: used for the #-part, may also be included inside $url
   attr: additional attributes for the a-tag (non-nested)
   dattr: if an array the whole thing will be embedded by a span with this attrs
   */
  function a    ($txt,$url=0,$args=array(),$anchor=NULL,
		 $attr=array(),$dattr=NULL){$this->add($this->a2arr($txt,$url,$args,$anchor,$attr,$dattr));}
  function a2str($txt,$url=0,$args=array(),$anchor=NULL,
		 $attr=array(),$dattr=NULL){return($this->_implode2str($this->a2arr($txt,$url,$args,$anchor,$attr,$dattr)));}
  function a2arr($txt,$url=0,$args=array(),$anchor=NULL,
		 $attr=array(),$dattr=NULL){
    if(strpos($url,'#')!==FALSE){// anchor has to be the last part -> bring him aside
      list($url,$anchor) = explode('#',$url,2);
    } 
    if(is_numeric($url) or is_null($url) or $url==''){
      if($url!=1) $args = array_merge($_GET,$args);
      $url = $this->url;
    }
    if(count($args)>0){
      if(!is_null(defex($args,'.'))) $args = array_merge($this->args,$args);
      $anch = defex($args,'#');
      if(is_null($anchor)) $anchor = $anch;
      $url .= (strpos($url,'?')===FALSE?'?':'&') . implode('&',$this->implode_urlargs($args));
    }
    if(!is_null($anchor)) $url .= '#' . $anchor;
    $attr = $this->_attr_auto($attr);
    $attr['tag'] = 'a';
    $attr['href'] = $url;
    $attr[] = $txt;
    if(!is_null($dattr)){
      $dattr = $this->_attr_auto($dattr);
      if(!isset($dattr['tag'])) $dattr['tag'] = 'span';
      $dattr[] = $attr;
      $attr = $dattr;
    }
    return($this->implode2arr($attr,array()));
  }


  /* to include images
   special attributes
   thumb: directly the filename of a preview (thumbnail)
          or a string to construct it from the src argument (using pathinfo)
	  %d will be replaced by the directory of src (no / at the end!)
	  %e will be replaced by the extension of src (no . at the beginning)
	  %n will be replaced by the basename of src (no path, . or extension)
	  %f will be replaced by the basename of src including extension
     to use javascript to open th picture with window.open set the attribute
     java to the new windowname. eg 'java'=>'myPicture'. To use the third
     argument of wondow.open too use for example
     'java'=>'myPicture width=310,height=400'
   */
  function img    ($src,$alt='',$attr=array()){$this->add($this->img2arr($src,$alt,$attr));}
  function img2str($src,$alt='',$attr=array()){return($this->_implode2str($this->img2arr($src,$alt,$attr)));}
  function img2arr($src,$alt='',$attr=array()){
    $attr = $this->_attr_auto($attr);
    if(isset($attr['thumb'])){
      $tmb = ops_array::key_extract($attr,'thumb');
      if(strpos($tmb,'%')!==FALSE){
	$pi = pathinfo($src);
	$tmb = str_replace('%d',$pi['dirname'],$tmb);
	$tmb = str_replace('%e',$pi['extension'],$tmb);
	$tmb = str_replace('%f',$pi['basename'],$tmb);
	$tmb = str_replace('%n',substr($pi['basename'],0,-1-strlen($pi['extension'])),$tmb);
      }
      if(isset($attr['java'])){
	$java = explode(' ',ops_array::key_extract($attr,'java'),2);
	$java = "_opc_ht_$java[0] = window.open('$src','$java[0]','$java[1]');_opc_ht_$java[0].focus();";
	$res = array('tag'=>'img','src'=>$tmb,'alt'=>$alt);
	$res = array('tag'=>'a','target'=>'_blank',
		     'onclick'=>'javascript:' . $java,$res);
      } else {
	$res = array('tag'=>'img','src'=>$tmb,'alt'=>$alt);
	$res = array('tag'=>'a','href'=>$src,$res);
      }
    } else {
      $res = array('tag'=>'img','src'=>$src,'alt'=>$alt);
    }
    return($this->implode2arr($res,$attr));
  }

  function table_colwidth    ($width){$this->add($this->table_colwidth2arr($width));}
  function table_colwidth2str($width){return($this->_implode2str($this->table_colwidth2arr($width)));}
  function table_colwidth2arr($width){
    if(is_integer($width)){
      $wid = floor(100/$width) . '%';
      return($this->tag2arr('colgroup',NULL,array('span'=>$width,'width'=>$wid)));
    } else {
      die("not yet coded");
    }
  }


  /* just shortcuts for p-span-div, b-i-tt and hr-br */
  function p    ($text,$attrs=array()){ return($this->tag    ('p',$text,$attrs));}
  function p2str($text,$attrs=array()){ return($this->tag2str('p',$text,$attrs));}
  function p2arr($text,$attrs=array()){ return($this->tag2arr('p',$text,$attrs));}

  function span    ($text,$attrs=array()){return($this->tag    ('span',$text,$attrs));}
  function span2str($text,$attrs=array()){return($this->tag2str('span',$text,$attrs));}
  function span2arr($text,$attrs=array()){return($this->tag2arr('span',$text,$attrs));}
  
  function div    ($text,$attrs=array()){return($this->tag    ('div',$text,$attrs));}
  function div2str($text,$attrs=array()){return($this->tag2str('div',$text,$attrs));}
  function div2arr($text,$attrs=array()){return($this->tag2arr('div',$text,$attrs));}

  function b    ($text,$attrs=array()){return($this->tag    ('b',$text,$attrs));}
  function b2str($text,$attrs=array()){return($this->tag2str('b',$text,$attrs));}
  function b2arr($text,$attrs=array()){return($this->tag2arr('b',$text,$attrs));}

  function i    ($text,$attrs=array()){return($this->tag    ('i',$text,$attrs));}
  function i2str($text,$attrs=array()){return($this->tag2str('i',$text,$attrs));}
  function i2arr($text,$attrs=array()){return($this->tag2arr('i',$text,$attrs));}

  function tt    ($text,$attrs=array()){return($this->tag    ('tt',$text,$attrs));}
  function tt2str($text,$attrs=array()){return($this->tag2str('tt',$text,$attrs));}
  function tt2arr($text,$attrs=array()){return($this->tag2arr('tt',$text,$attrs));}

  function br    ($attr=array()){return($this->tag    ('br',NULL,$attr));}
  function br2str($attr=array()){return($this->tag2str('br',NULL,$attr));}
  function br2arr($attr=array()){return($this->tag2arr('br',NULL,$attr));}

  function hr    ($attr=array()){return($this->tag    ('hr',NULL,$attr));}
  function hr2str($attr=array()){return($this->tag2str('hr',NULL,$attr));}
  function hr2arr($attr=array()){return($this->tag2arr('hr',NULL,$attr));}


  /*
   returns the way back to the file
   mode
     0: complete; eg: http://www.whatev.er/max/this.php
   */
  function myself($mode=0,$prot=NULL){
    $ser = $_SERVER;
    if(is_null($prot)) $prot = $this->server_protocol();
    switch($mode){
    default:
      $url = $prot . def($ser,'SERVER_NAME') . $ser['SCRIPT_NAME']; 
    }
    return($url);
  }

  function server_protocol($add='://'){
    return(strtolower(substr(def($_SERVER,'SERVER_PROTOCOL'),0,
			     strpos(def($_SERVER,'SERVER_PROTOCOL'),'/')))
	   . $add);
  }


  /* function to handle temporary stacks */
  function _tmpstack_open(&$stack,&$obj,$new=array()){
    $stack[] = $obj;
    $obj = $new;
  }
  function _tmpstack_close(&$stack,&$obj,$nlev=1){
    if(is_null($nlev)) $nlev = count($stack);
    for($ii=0;$ii<$nlev;$ii++){
      $cv = $obj;
      $obj = array_pop($stack);
      $obj[] = $cv;
    }
  }

  /*
   first element is the name (string) of an existing method
   these will be called by the other elements
   optional the first arg may be an integer and the second the fkt-name
    -> 0: call directly; 1: call *2str; 2: call as *2arr
   */
  function call(/*[0|1|2]*/ $fkt /* other args*/){
    $ar = func_get_args();
    $typ = array_shift($ar);
    if(is_numeric($typ)) {
      $fkt = array_shift($ar);
      if($typ==1) $fkt .= '2str';
      elseif($typ==2) $fkt .= '2arr';
    } else $fkt = $typ;
    if(!method_exists($this,$fkt)) return(FALSE);
    return(call_user_func_array(array(&$this,$fkt),$ar));
  }


  function is_single($tag){
    return(in_array($tag,array('br','hr','input','meta','link','base')));
  }

  //used if srclayout >0; number of newlines in source if this tag is opend
  function _indent($tag){
    switch($tag){
    case 'head': case 'meta': case 'link': case 'style': 
    case 'br': case 'hr': 
    case 'td': case 'th': case 'li': case 'dt': case 'dd':
    case 'option': case 'optgroup': 
      return(1);
    case 'script':
    case 'h4': case 'p': case 'div': case 'pre': 
    case 'tr': case 'ul': case 'ol': case 'fieldset':
      return(2);
    case 'h3': case 'form': case 'table': case 'body':
      return(3);
    case 'h2':
      return(4);
    case 'h1':
      return(5);
    }
    return(0);
  }

  function _die($msg=NULL){
    if(!is_null($msg))
      $this->p($msg,'border: solid 2px red; background-color: #FFee22; margin: 10px; padding: 15px; font-weight: bold; font-size: large;');
    echo $this->output();
    die;
  }
}

?>